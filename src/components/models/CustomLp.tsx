/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 C:\Users\parallel\Downloads\room\record.glb -t -s -i -T -S 
Files: C:\Users\parallel\Downloads\room\record.glb [108.04KB] > C:\Users\parallel\record-transformed.glb [22.37KB] (79%)
*/

import { useGLTF, useTexture } from "@react-three/drei";
import { ThreeEvent } from "@react-three/fiber";
import { useRef, useMemo } from "react";
import { Group, MeshStandardMaterial } from "three";
import { GLTF } from "three-stdlib";
import { useFrame, useThree } from "@react-three/fiber";

import useAnimationStore from "@/states/animationStore";
import { eventManager } from "@/Scene/managers/EventManager";
import { focusLp, placeLp, returnLp } from "Scene/animations/lp";

import { Album } from "@/types/Album";
import useSceneStore from "@/states/sceneStore";
import { LP_GAP, LP_ROOT } from "@/constants/lp";

type GLTFResult = GLTF & {
    nodes: {
        ["Box001_Material_#25_0"]: THREE.Mesh;
        ["Box001_Material_#37_0"]: THREE.Mesh;
        ["Box001_Material_#49_0"]: THREE.Mesh;
        ["Box001_Material_#73_0"]: THREE.Mesh;
        ["Cylinder001_Material_#85_0"]: THREE.Mesh;
    };
    materials: {
        Material_25: THREE.MeshStandardMaterial;
        Material_37: THREE.MeshStandardMaterial;
        Material_49: THREE.MeshStandardMaterial;
        Material_73: THREE.MeshStandardMaterial;
        Material_85: THREE.MeshStandardMaterial;
    };
};

export function CustomLp({ album, order }: { album: Album; order: number }) {
    // asset data
    const { nodes, materials } = useGLTF(
        "/record-transformed.glb"
    ) as GLTFResult;
    const albumTexture = useTexture(album.cover);
    const coverMaterial = useMemo(() => {
        return new MeshStandardMaterial({ map: albumTexture });
    }, [albumTexture]);

    const lpState = useRef<
        "idle" | "focus" | "returning" | "playing" | "placing"
    >("idle");
    const groupRef = useRef<Group>(null);

    const { currentAnim } = useAnimationStore();
    const { camera } = useThree();
    const { station } = useSceneStore();

    // 각 CustomLp가 자신의 애니메이션을 업데이트함
    useFrame(() => {
        if (lpState.current === "idle") return;
        if (groupRef.current) {
            const coverRef = groupRef.current.getObjectByName("cover") as Group;
            const recordRef = groupRef.current.getObjectByName(
                "record"
            ) as Group;

            if (lpState.current === "focus") {
                focusLp(camera, groupRef.current, coverRef, recordRef);
            } else if (lpState.current === "returning") {
                returnLp(groupRef.current, coverRef, recordRef, order, () => {
                    lpState.current = "idle";
                });
            } else if (lpState.current === "placing") {
                if (!station) return;
                placeLp(coverRef, recordRef, station);
            }
        }
    });

    const handleClick = (e: ThreeEvent<MouseEvent>) => {
        e.stopPropagation();
        if (!groupRef.current || currentAnim === "playing") return;

        const isSelected = eventManager.isSelected(album.id);

        if (isSelected) {
            lpState.current = "returning";
            eventManager.unselect();
        } else {
            lpState.current = "focus";
            eventManager.select({
                album,
                onUnselect: () => {
                    lpState.current = "returning";
                },
                onPlaying: () => {
                    lpState.current = "placing";
                },
            });
        }
    };

    return (
        <group
            name={`lpOBJ-${album.id}`}
            ref={groupRef}
            position-x={order * LP_GAP}
            rotation-x={LP_ROOT.ROT.init[0]}
            onClick={handleClick}
        >
            <group name="cover">
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes["Box001_Material_#25_0"].geometry}
                    material={coverMaterial}
                    position={[-0.019, 0, 0]}
                    scale={0.03}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes["Box001_Material_#37_0"].geometry}
                    material={materials.Material_37}
                    position={[-0.019, 0, 0]}
                    scale={0.03}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes["Box001_Material_#49_0"].geometry}
                    material={materials.Material_49}
                    position={[-0.019, 0, 0]}
                    scale={0.03}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes["Box001_Material_#73_0"].geometry}
                    material={materials.Material_73}
                    position={[-0.019, 0, 0]}
                    scale={0.03}
                />
            </group>
            <group
                name="record"
                position-z={-0.01}
            >
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes["Cylinder001_Material_#85_0"].geometry}
                    material={materials.Material_85}
                    position={[0, 0, 0.001]}
                    scale={0.135}
                />
            </group>
        </group>
    );
}

useGLTF.preload("/record-transformed.glb");
